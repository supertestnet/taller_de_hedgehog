<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, user-scalable=no">
        <title>Hedgehog Workshop</title>
        <script src="https://supertestnet.github.io/bankify/super_nostr.js"></script>
        <script src="https://unpkg.com/@dashincubator/ripemd160/ripemd160.js"></script>
        <script src="https://supertestnet.github.io/testnet_generator/chain_client.js"></script>
        <script src="https://unpkg.com/@cmdcode/tapscript@1.4.0"></script>
        <script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
<!--
        <script src="file:///home/supertestnet/bitcoin_projects/testnet_generator/super_nostr.js"></script>
        <script src="file:///home/supertestnet/bitcoin_projects/testnet_generator/ripemd160.js"></script>
        <script src="file:///home/supertestnet/bitcoin_projects/testnet_generator/tapscript@1.5.3"></script>
        <script src="file:///home/supertestnet/bitcoin_projects/testnet_generator/noble-secp256k1@1.2.14"></script>
-->
        <script>
            var hedgehog = {
                network: "testnet",
                state: {},
                keypairs: {},
                state_obj: {
                    alices_privkey: null,
                    bobs_privkey: null,
                    alices_pubkey: null,
                    bobs_pubkey: null,
                    alices_address: null,
                    bobs_address: null,
                    multisig_script: null,
                    multisig_tree: null,
                    multisig_utxo_info: {},
                    i_was_last_to_send: false,
                    alice_can_revoke: [],
                    bob_can_revoke: [],
                    balances: [],
                    balances_before_most_recent_send: [],
                    balances_before_most_recent_receive: [],
                    alices_revocation_preimages: [],
                    alices_revocation_hashes: [],
                    bobs_revocation_preimages: [],
                    bobs_revocation_hashes: [],
                    txids_to_watch_for: {},
                    latest_force_close_txs: [],
                    extra_outputs: [],
                    label: null,
                    i_force_closed: false,
                },
                nums_point: "a".repeat( 64 ),
                hexToBytes: hex => Uint8Array.from( hex.match( /.{1,2}/g ).map( byte => parseInt( byte, 16 ) ) ),
                bytesToHex: bytes => bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, "0" ), "" ),
                rmd160: s => {
                    if ( typeof s == "string" ) s = new TextEncoder().encode( s );
                    var hash = RIPEMD160.create();
                    hash.update( new Uint8Array( s ) );
                    return hedgehog.bytesToHex( hash.digest() );
                },
                isValidHex: hex => {
                    if ( !hex ) return;
                    var length = hex.length;
                    if ( length % 2 ) return;
                    try {
                        var bigint = BigInt( "0x" + hex, "hex" );
                    } catch( e ) {
                        return;
                    }
                    var prepad = bigint.toString( 16 );
                    var i; for ( i=0; i<length; i++ ) prepad = "0" + prepad;
                    var padding = prepad.slice( -Math.abs( length ) );
                    return ( padding === hex );
                },
                getVin: ( txid, vout, amnt, addy, sequence ) => {
                    var input = {
                        txid,
                        vout,
                        prevout: {
                            value: amnt,
                            scriptPubKey: tapscript.Address.toScriptPubKey( addy ),
                        },
                    }
                    if ( sequence ) input[ "sequence" ] = sequence;
                    return input;
                },
                getVout: ( amnt, addy ) => ({
                    value: amnt,
                    scriptPubKey: tapscript.Address.toScriptPubKey( addy ),
                }),
                makeAddress: ( chan_id, scripts ) => {
                    var tree = scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var pubkey = hedgehog.nums_point;
                    var [ tpubkey ] = tapscript.Tap.getPubKey( pubkey, { tree });
                    return tapscript.Address.p2tr.fromPubKey( tpubkey, hedgehog.network );
                },
                makeAlicesRevocationScript: chan_id => ([
                    [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIG", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIGADD", 2, "OP_EQUAL" ],
                    [ "OP_RIPEMD160", hedgehog.state[ chan_id ].alices_revocation_hashes[ hedgehog.state[ chan_id ].alices_revocation_hashes.length - 1 ], "OP_EQUALVERIFY", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                    //TODO: change the 10 to 4032
                    [ 10, "OP_CHECKSEQUENCEVERIFY", "OP_DROP", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIG" ],
                ]),
                makeBobsRevocationScript: chan_id => ([
                    [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIG", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIGADD", 2, "OP_EQUAL" ],
                    [ "OP_RIPEMD160", hedgehog.state[ chan_id ].bobs_revocation_hashes[ hedgehog.state[ chan_id ].bobs_revocation_hashes.length - 1 ], "OP_EQUALVERIFY", hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIG" ],
                    //TODO: change the 10 to 4032
                    [ 10, "OP_CHECKSEQUENCEVERIFY", "OP_DROP", hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIG" ],
                ]),
                openChannel: async ( push_all_funds_to_counterparty, data_from_counterparty ) => {
                    //there are three ways to open a channel:
                    //the first way is as Bob, opening a channel to Alice unilaterally
                    //the second way is as Alice, accepting a channel Bob already unilaterally opened
                    //the third way is as Alice, opening a new channel cooperatively with Bob
                    //the second and third ways are handled in the first "if" statement below, and
                    //the first way is handled in the code after the following "if" statement, because
                    //a unilateral channel open requires pushing all funds to your counterparty
                    //in theory there are two more ways: Bob could open a channel to Alice cooperatively
                    //and thus keep some or all of the funds on his side, or Alice could open a channel
                    //to Bob unilaterally and thus push all funds to Bob's side. To do these examples,
                    //just have Alice open a channel with push_all_funds_to_counterparty set to true
                    //or have Bob open a channel with push_all_funds_to_counterparty set to false
                    if ( !push_all_funds_to_counterparty || data_from_counterparty ) {
                        var has_data = data_from_counterparty || confirm( `Click ok if someone sent you channel opening data or cancel if you are opening this channel yourself` );
                        if ( has_data ) {
                            if ( data_from_counterparty ) var data = data_from_counterparty;
                            else var data = JSON.parse( prompt( `Enter the data your counterparty sent you` ) );
                            var label = prompt( `Please enter a label for the person who opened a channel with you -- you will use this label later when sending them money` );
                            if ( !label ) return alert( `the label is mandatory, try again` );
                            var label_exists = false;
                            var i; for ( i=0; i<Object.keys( hedgehog.state ).length; i++ ) {
                                var chan_id = Object.keys( hedgehog.state )[ i ];
                                if ( hedgehog.state[ chan_id ].label.toLowerCase() !== label.toLowerCase() ) continue;
                                label_exists = true;
                            }
                            if ( label_exists ) return alert( `you already used that label, try again` );
                            //TODO: validate the data so you don't acccidentally accept irredeemable coins
                            //or crash your wallet

                            //create the state object
                            var pubkey = data[ "recipient_pubkey" ];
                            if ( !( pubkey in hedgehog.keypairs ) ) return alert( `Your counterparty tried to scam you! Do not interact with them any further` );
                            var privkey = hedgehog.keypairs[ pubkey ][ "privkey" ];
                            var preimage = hedgehog.keypairs[ pubkey ][ "preimage" ];
                            var chan_id = data[ "chan_id" ];
                            hedgehog.state[ chan_id ] = JSON.parse( JSON.stringify( hedgehog.state_obj ) );
                            hedgehog.state[ chan_id ][ "label" ] = label;
                            hedgehog.state[ chan_id ][ "alices_privkey" ] = privkey;
                            hedgehog.state[ chan_id ][ "alices_pubkey" ] = pubkey;
                            hedgehog.state[ chan_id ][ "bobs_pubkey" ] = data[ "sender_pubkey" ];
                            hedgehog.state[ chan_id ][ "multisig_utxo_info" ] = data[ "utxo_info" ];
                            hedgehog.state[ chan_id ][ "alices_address" ] = hedgehog_workshop.btc_address;
                            hedgehog.state[ chan_id ][ "bobs_address" ] = data[ "bobs_address" ];
                            hedgehog.state[ chan_id ].alices_revocation_preimages.push( preimage );
                            var hash = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                            hedgehog.state[ chan_id ].alices_revocation_hashes.push( hash );
                            var multisig_script = [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIG", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIGADD", 2, "OP_EQUAL" ];
                            var multisig_tree = [ tapscript.Tap.encodeScript( multisig_script ) ];
                            hedgehog.state[ chan_id ].multisig_script = multisig_script;
                            hedgehog.state[ chan_id ].multisig_tree = multisig_tree;
                            hedgehog.state[ chan_id ].multisig = hedgehog.makeAddress( chan_id, [ multisig_script ] );

                            //temporarily pretend the entire balance is on Bob's side so he can
                            //send it to Alice using the regular send command
                            var amnt = data[ "amnt" ];
                            hedgehog.state[ chan_id ].balances = [ 0, amnt ];
                            var opening = true;

                            //validate the initial state using the regular "receive" function
                            var opened = await hedgehog.receive( {amnt: amnt - 500 - 500, sig_1: data[ "sig_1" ], sig_3: data[ "sig_3" ], chan_id: data[ "chan_id" ], hash: data[ "hash" ]} );
                            if ( opened !== true ) return;

                            //update the state to reflect alice's ability to withdraw 100%
                            hedgehog.state[ chan_id ].balances = [ amnt, 0 ];
                        }
                        return;
                    }

                    //handle the case where Bob opens a channel to Alice unilaterally
                    //start by preparing the state object
                    var label = prompt( `Please enter a label for the person you want to open a channel with -- you will use this label later when sending them money` );
                    if ( !label ) return alert( `the label is mandatory, try again` );
                    var label_exists = false;
                    var i; for ( i=0; i<Object.keys( hedgehog.state ).length; i++ ) {
                        var chan_id = Object.keys( hedgehog.state )[ i ];
                        if ( hedgehog.state[ chan_id ].label.toLowerCase() !== label.toLowerCase() ) continue;
                        label_exists = true;
                    }
                    if ( label_exists ) return alert( `you already used that label, try again` );
                    var amnt_to_send = Number( prompt( `enter the amount of sats to send them in this channel` ) );
                    if ( !amnt_to_send ) return;
                    var { confirmed_balance, unconfirmed_balance } = await hedgehog_workshop.getBalances();
                    var total_balance = confirmed_balance + unconfirmed_balance;
                    if ( total_balance - amnt_to_send < 0 ) return alert( `you tried to send more than your balance, or did not leave enough for mining fees. Try again` );
                    var alices_pubkey_and_hash = JSON.parse( prompt( `Enter your counterparty's channel opening data` ) );
                    if ( !alices_pubkey_and_hash ) return;

                    //test sending the coins to be sure it will work
                    var change_address = hedgehog_workshop.btc_address;
                    var sats_per_byte = 1;
                    var utxos = JSON.parse( JSON.stringify( hedgehog_workshop.utxos ) );
                    utxos.forEach( ( utxo, index ) => {
                        utxos[ index ][ "address" ] = hedgehog_workshop.btc_address;
                        utxos[ index ][ "privkey" ] = hedgehog_workshop.btc_privkey;
                    });
                    var test_result = await hedgehog_workshop.spendCoins( change_address, amnt_to_send, sats_per_byte, utxos, change_address );
                    if ( !hedgehog_workshop.isValidHex( test_result ) ) return alert( test_result );
                    var chan_id = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                    hedgehog.state[ chan_id ] = JSON.parse( JSON.stringify( hedgehog.state_obj ) );
                    hedgehog.state[ chan_id ].label = label;
                    hedgehog.state[ chan_id ].bobs_privkey = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                    hedgehog.state[ chan_id ].bobs_pubkey = nobleSecp256k1.getPublicKey( hedgehog.state[ chan_id ].bobs_privkey, true ).substring( 2 );
                    hedgehog.state[ chan_id ][ "alices_pubkey" ] = alices_pubkey_and_hash[ 0 ];
                    hedgehog.state[ chan_id ][ "alices_address" ] = alices_pubkey_and_hash[ 2 ];
                    hedgehog.state[ chan_id ][ "bobs_address" ] = hedgehog_workshop.btc_address;
                    hedgehog.state[ chan_id ].alices_revocation_hashes.push( alices_pubkey_and_hash[ 1 ] );
                    var multisig_script = [ hedgehog.state[ chan_id ].alices_pubkey, "OP_CHECKSIG", hedgehog.state[ chan_id ].bobs_pubkey, "OP_CHECKSIGADD", 2, "OP_EQUAL" ];
                    var multisig_tree = [ tapscript.Tap.encodeScript( multisig_script ) ];
                    hedgehog.state[ chan_id ].multisig_script = multisig_script;
                    hedgehog.state[ chan_id ].multisig_tree = multisig_tree;
                    hedgehog.state[ chan_id ].multisig = hedgehog.makeAddress( chan_id, [ multisig_script ] );
                    console.log( "address:", hedgehog.state[ chan_id ].multisig );

                    //actually send the coins
                    var txhex = await hedgehog_workshop.spendCoins( hedgehog.state[ chan_id ].multisig, amnt_to_send, sats_per_byte, utxos, change_address );
                    chain_client.commander( hedgehog_workshop.network_string.split( "," ), "broadcast", txhex );
                    var txid = tapscript.Tx.util.getTxid( txhex );
                    var vout = 0;
                    var amnt = amnt_to_send;

                    hedgehog.state[ chan_id ].multisig_utxo_info = {
                        txid,
                        vout,
                        amnt,
                    }

                    //temporarily pretend the entire balance is on Bob's side so he can
                    //send it to Alice using the regular send command
                    hedgehog.state[ chan_id ].balances = [ 0, amnt ];

                    //prepare the transaction that moves all funds to Alice's side
                    var opening = true;
                    var sigs_and_stuff = hedgehog.send( chan_id, amnt - 500 - 500, opening );
                    sigs_and_stuff[ "amnt" ] = amnt;
                    sigs_and_stuff[ "type" ] = "new_channel";
                    sigs_and_stuff[ "bobs_address" ] = hedgehog.state[ chan_id ][ "bobs_address" ];

                    //update the state to reflect alice's ability to withdraw 100%
                    hedgehog.state[ chan_id ].balances = [ amnt, 0 ];
                    hedgehog.state[ chan_id ].balances_before_most_recent_receive = [ amnt, 0 ];

                    return sigs_and_stuff;
                },
                send: ( chan_id, amnt, opening ) => {
                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //if I am the previous sender, restore the state to what it was before
                    //I last sent so I can overwrite my previous state update
                    var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                    if ( hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        hedgehog.state[ chan_id ].balances = hedgehog.state[ chan_id ].balances_before_most_recent_send;
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bob_can_revoke.pop();
                            hedgehog.state[ chan_id ].alices_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                        } else {
                            hedgehog.state[ chan_id ].alice_can_revoke.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_preimages.pop();
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                        }
                    }

                    //unless an amount is already given, prompt the user to enter an amount
                    if ( !amnt ) amnt = Number( prompt( `Please enter an amount you want to send to your counterparty` ) );
                    var current_balance = am_alice ? current_balances[ 0 ] : current_balances[ 1 ];
                    if ( amnt > current_balance - ( 500 + 500 ) ) return alert( `cannot send more than ${current_balance - ( 500 + 500 )} sats` );

                    //update the amnt variable if necessary. For example,
                    //if the prev balance was 0 for Bob but I sent him 5k,
                    //current_balances would say he has 5k. If I am now
                    //sending him 1k, amnt should be 6k, which is 
                    //( current_balances[ 1 ] - prev_balance[ 1 ] ) + amnt
                    if ( hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        if ( am_alice ) amnt = ( current_balances[ 1 ] - hedgehog.state[ chan_id ].balances[ 1 ] ) + amnt;
                        else amnt = ( current_balances[ 0 ] - hedgehog.state[ chan_id ].balances[ 0 ] ) + amnt;
                    }

                    //create the revocation scripts so the recipient can revoke this state later
                    if ( am_alice ) {
                        var latest_scripts = hedgehog.makeBobsRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( chan_id, latest_scripts );
                        hedgehog.state[ chan_id ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                    } else {
                        var latest_scripts = hedgehog.makeAlicesRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( chan_id, latest_scripts );
                        hedgehog.state[ chan_id ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                    }

                    //create and sign the timeout tx in case your counterparty takes
                    //too long to force close or disappears during a force closure
                    var utxo_info = hedgehog.state[ chan_id ].multisig_utxo_info;
                    var balances = hedgehog.state[ chan_id ].balances;
                    var original_amnt = balances[ 0 ] + balances[ 1 ];
                    //tx0 sends all the money from the multisig into alice_can_revoke
                    //or bob_can_revoke (depending on who is sending)
                    var tx0 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                        vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                    });
                    var tx0_id = tapscript.Tx.util.getTxid( tx0 );
                    var alices_address = hedgehog.state[ chan_id ].alices_address;
                    var bobs_address = hedgehog.state[ chan_id ].bobs_address;
                    if ( am_alice ) var my_address = alices_address;
                    else var my_address = bobs_address;
                    var timeout_tx = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 10 to 4032
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 10 )],
                        vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                    });
                    if ( am_alice ) var privkey = hedgehog.state[ chan_id ].alices_privkey;
                    else var privkey = hedgehog.state[ chan_id ].bobs_privkey;
                    var timeout_tx_script = latest_scripts[ 2 ];
                    var timeout_tx_target = tapscript.Tap.encodeScript( timeout_tx_script );
                    var timeout_tx_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var timeout_sig = tapscript.Signer.taproot.sign( privkey, timeout_tx, 0, { extension: timeout_tx_target }).hex;
                    var [ _, cblock ] = tapscript.Tap.getPubKey( hedgehog.nums_point, { tree: timeout_tx_tree, target: timeout_tx_target });
                    timeout_tx.vin[ 0 ].witness = [ timeout_sig, timeout_tx_script, cblock ];
                    hedgehog.state[ chan_id ].txids_to_watch_for[ tx0_id ] = {
                        tx0: tapscript.Tx.encode( tx0 ).hex,
                        timeout_tx: tapscript.Tx.encode( timeout_tx ).hex,
                    }

                    //create tx1 to distribute the funds however the sender wishes to do so
                    var tx1 = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 2016
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 5 )],
                        vout: [],
                    });

                    //increase the recipient's balance by amnt and decrease the sender's by
                    //amnt and two mining fees
                    if ( am_alice ) {
                        var amnt_for_alice = balances[ 0 ] - amnt - 500 - 500;
                        var amnt_for_bob = balances[ 1 ] + amnt;
                    } else {
                        var amnt_for_alice = balances[ 0 ] + amnt;
                        var amnt_for_bob = balances[ 1 ] - amnt - 500 - 500;
                        if ( opening ) var amnt_for_bob = 0;
                    }
                    if ( am_alice ) {
                        if ( amnt_for_alice ) tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    } else {
                        if ( amnt_for_alice ) tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    }
                    // console.log( "tx0:", JSON.stringify( tx0 ) );
                    // console.log( "tx1:", JSON.stringify( tx1 ) );

                    //Sign both of these transactions, but sign tx1 with a sig that
                    //is only valid after a relative timelock of 2016 blocks expires.
                    var tx0_script = hedgehog.state[ chan_id ].multisig_script;
                    var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                    var tx0_tree = hedgehog.state[ chan_id ].multisig_tree;
                    var tx1_script = latest_scripts[ 0 ];
                    var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                    var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var sig_1 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                    //sig_3 is for tx1 and it has a relative timelock of 2016 blocks
                    //because tx1's only input (see above) has sequence number 2016
                    var sig_3 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;
                    var sighash_3 = tapscript.Signer.taproot.hash( tx1, 0, { extension: tx1_target }).hex;

                    //If necessary, create a revocation sig that conditionally revokes
                    //the prior state
                    var conditional_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length ) conditional_revocation_is_necessary = true;
                    if ( conditional_revocation_is_necessary ) {
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) new_tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) new_tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        var new_tx1_script = prev_scripts[ 0 ];
                        var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                        var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var conditional_revocation_sig = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                    }

                    //If necessary, prepare to reveal whichever preimage fully revokes
                    //the state prior to the prior state (yes, doubly prior)
                    var full_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 1 ) full_revocation_is_necessary = true;
                    if ( full_revocation_is_necessary ) {
                        if ( am_alice ) var full_revocation_preimage = hedgehog.state[ chan_id ].alices_revocation_preimages[ hedgehog.state[ chan_id ].alices_revocation_preimages.length - 2 ];
                        else var full_revocation_preimage = hedgehog.state[ chan_id ].bobs_revocation_preimages[ hedgehog.state[ chan_id ].bobs_revocation_preimages.length - 2 ];
                    }

                    //Prepare a preimage/hash pair for the recipient to use in their
                    //next state update
                    var preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                    var hash = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                    if ( am_alice ) {
                        hedgehog.state[ chan_id ].alices_revocation_preimages.push( preimage );
                        hedgehog.state[ chan_id ].alices_revocation_hashes.push( hash );
                    } else {
                        hedgehog.state[ chan_id ].bobs_revocation_preimages.push( preimage );
                        hedgehog.state[ chan_id ].bobs_revocation_hashes.push( hash );
                    }
                    //Create an object to send all this data to the recipient
                    var object = {
                        sig_1,
                        sig_3,
                        hash,
                        amnt,
                        chan_id,
                    }
                    if ( conditional_revocation_sig ) object[ "conditional_revocation_sig" ] = conditional_revocation_sig;
                    if ( full_revocation_is_necessary ) object[ "full_revocation_preimage" ] = full_revocation_preimage;
                    if ( opening ) object[ "utxo_info" ] = utxo_info;
                    if ( opening ) object[ "sender_pubkey" ] = hedgehog.state[ chan_id ].bobs_pubkey;
                    if ( opening ) object[ "recipient_pubkey" ] = hedgehog.state[ chan_id ].alices_pubkey;

                    //update the balances
                    hedgehog.state[ chan_id ].balances_before_most_recent_send = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                    if ( am_alice ) {
                        hedgehog.state[ chan_id ].balances = [ balances[ 0 ] - amnt, balances[ 1 ] + amnt ];
                        hedgehog.state[ chan_id ].balances_before_most_recent_receive = [ balances[ 0 ] - amnt, balances[ 1 ] + amnt ];
                    } else {
                        hedgehog.state[ chan_id ].balances = [ balances[ 0 ] + amnt, balances[ 1 ] - amnt ];
                        hedgehog.state[ chan_id ].balances_before_most_recent_receive = [ balances[ 0 ] + amnt, balances[ 1 ] - amnt ];
                    }

                    //update state of who was last to send
                    hedgehog.state[ chan_id ].i_was_last_to_send = true;

                    return object;
                },
                receive: async data => {
                    var data_was_here_originally = data;
                    if ( !data ) data = JSON.parse( prompt( `Enter the data from your counterparty` ) );
                    var chan_id = data[ "chan_id" ];
                    if ( data.hasOwnProperty( "type" ) && data.type === "new_channel" ) return hedgehog.openChannel( false, data );

                    //automatically find out if I am Alice or Bob using the chan_id
                    var am_alice = !!hedgehog.state[ chan_id ].alices_privkey;

                    //if I recently received, restore the state to what it was before
                    //I last received so I can overwrite my previous state update
                    //but keep a copy of the old state so that, if the new state is
                    //invalid, I can restore the old state
                    if ( !hedgehog.state[ chan_id ].i_was_last_to_send ) {
                        var current_balances = JSON.parse( JSON.stringify( hedgehog.state[ chan_id ].balances ) );
                        hedgehog.state[ chan_id ].balances = hedgehog.state[ chan_id ].balances_before_most_recent_receive;
                        if ( !hedgehog.state[ chan_id ].balances.length ) {
                            var sum = current_balances[ 0 ] + current_balances[ 1 ];
                            if ( am_alice ) hedgehog.state[ chan_id ].balances = [ 0, sum ];
                            else hedgehog.state[ chan_id ].balances = [ sum, 0 ];
                        }
                        if ( am_alice ) {
                            var old_rev_hashes = hedgehog.state[ chan_id ].bobs_revocation_hashes.pop();
                            var other_rev_info = hedgehog.state[ chan_id ].alice_can_revoke.pop();
                        } else {
                            var old_rev_hashes = hedgehog.state[ chan_id ].alices_revocation_hashes.pop();
                            var other_rev_info = hedgehog.state[ chan_id ].bob_can_revoke.pop();
                        }
                    }

                    //push your counterparty's payment hash to their hashes object
                    if ( am_alice ) hedgehog.state[ chan_id ].bobs_revocation_hashes.push( data[ "hash" ] );
                    else hedgehog.state[ chan_id ].alices_revocation_hashes.push( data[ "hash" ] );

                    //create the revocation scripts so the recipient can revoke this state later
                    if ( am_alice ) {
                        var latest_scripts = hedgehog.makeAlicesRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( chan_id, latest_scripts );
                        hedgehog.state[ chan_id ].alice_can_revoke.push( [ revocable_address, latest_scripts ] );
                    } else {
                        var latest_scripts = hedgehog.makeBobsRevocationScript( chan_id );
                        var revocable_address = hedgehog.makeAddress( chan_id, latest_scripts );
                        hedgehog.state[ chan_id ].bob_can_revoke.push( [ revocable_address, latest_scripts ] );
                    }

                    //create tx0 to send all the money from the multisig into alice_can_revoke
                    //or bob_can_revoke (depending on who is sending)
                    var utxo_info = hedgehog.state[ chan_id ].multisig_utxo_info;
                    var amnt = data[ "amnt" ];
                    var balances = hedgehog.state[ chan_id ].balances;
                    var alices_address = hedgehog.state[ chan_id ].alices_address;
                    var bobs_address = hedgehog.state[ chan_id ].bobs_address;
                    var original_amnt = balances[ 0 ] + balances[ 1 ];
                    var tx0 = tapscript.Tx.create({
                        vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                        vout: [hedgehog.getVout( original_amnt - 500, revocable_address )],
                    });
                    var tx0_id = tapscript.Tx.util.getTxid( tx0 );

                    //create tx1 to distribute the funds however the sender wishes to do so
                    var tx1 = tapscript.Tx.create({
                        //TODO: change the sequence number (relative timelock) from 5 to 2016
                        vin: [hedgehog.getVin( tx0_id, 0, original_amnt - 500, revocable_address, 5 )],
                        vout: [],
                    });

                    //increase the recipient's balance by amnt and decrease the sender's by
                    //amnt and two mining fees
                    if ( am_alice ) {
                        var amnt_for_alice = balances[ 0 ] + amnt;
                        var amnt_for_bob = balances[ 1 ] - amnt - 500 - 500;
                        if ( data_was_here_originally ) var amnt_for_bob = 0;
                    } else {
                        var amnt_for_alice = balances[ 0 ] - amnt - 500 - 500;
                        var amnt_for_bob = balances[ 1 ] + amnt;
                    }
                    if ( am_alice ) {
                        if ( amnt_for_alice ) tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    } else {
                        if ( amnt_for_alice ) tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                        if ( amnt_for_bob ) tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                    }
                    // console.log( "tx0:", JSON.stringify( tx0 ) );
                    // console.log( "tx1:", JSON.stringify( tx1 ) );

                    //validate the signatures by which the sender creates the new state
                    if ( am_alice ) var pubkey_to_validate_against = hedgehog.state[ chan_id ].bobs_pubkey;
                    else var pubkey_to_validate_against = hedgehog.state[ chan_id ].alices_pubkey;
                    var tx0_script = hedgehog.state[ chan_id ].multisig_script;
                    var tx0_target = tapscript.Tap.encodeScript( tx0_script );
                    var tx0_tree = hedgehog.state[ chan_id ].multisig_tree;
                    var tx1_script = latest_scripts[ 0 ];
                    var tx1_target = tapscript.Tap.encodeScript( tx1_script );
                    var tx1_tree = latest_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var sig_1 = data[ "sig_1" ];
                    var sighash_1 = tapscript.Signer.taproot.hash( tx0, 0, { extension: tx0_target }).hex;
                    var is_valid_1 = await nobleSecp256k1.schnorr.verify( sig_1, sighash_1, pubkey_to_validate_against );
                    var sig_3 = data[ "sig_3" ];
                    var sighash_3 = tapscript.Signer.taproot.hash( tx1, 0, { extension: tx1_target }).hex;
                    var is_valid_3 = await nobleSecp256k1.schnorr.verify( sig_3, sighash_3, pubkey_to_validate_against );
                    if ( !is_valid_1 || !is_valid_3 ) {
                        //restore old state and inform user this state update was invalid
                        if ( am_alice ) {
                            hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                        } else {
                            hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                            hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                        }
                        return alert( `Your counterparty sent you invalid main-sig data so it will be ignored` );
                    }

                    //Sign both of these transactions, but sign tx1 with a sig that
                    //is only valid after a relative timelock of 2016 blocks expires.
                    if ( am_alice ) var privkey = hedgehog.state[ chan_id ].alices_privkey;
                    else var privkey = hedgehog.state[ chan_id ].bobs_privkey;
                    var sig_2 = tapscript.Signer.taproot.sign( privkey, tx0, 0, { extension: tx0_target }).hex;
                    var sig_4 = tapscript.Signer.taproot.sign( privkey, tx1, 0, { extension: tx1_target }).hex;

                    //If necessary, validate the signature by which the sender
                    //conditionally revokes the old state and cosign the revocation
                    var conditional_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 1 ) conditional_revocation_is_necessary = true;
                    if ( conditional_revocation_is_necessary ) {
                        if ( !( "conditional_revocation_sig" in data ) ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (no cond sig) so it will be ignored` );
                        }
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 1 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 1 ][ 1 ];
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        var new_tx1 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [],
                        });
                        if ( am_alice ) {
                            if ( amnt_for_alice ) new_tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        } else {
                            if ( amnt_for_alice ) new_tx1.vout.push( hedgehog.getVout( amnt_for_alice, alices_address ) );
                            if ( amnt_for_bob ) new_tx1.vout.push( hedgehog.getVout( amnt_for_bob, bobs_address ) );
                        }
                        var new_tx1_script = prev_scripts[ 0 ];
                        var new_tx1_target = tapscript.Tap.encodeScript( new_tx1_script );
                        var new_tx1_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var conditional_revocation_sig = data[ "conditional_revocation_sig" ];
                        var conditional_sighash = tapscript.Signer.taproot.hash( new_tx1, 0, { extension: new_tx1_target }).hex;
                        var conditional_is_valid = await nobleSecp256k1.schnorr.verify( conditional_revocation_sig, conditional_sighash, pubkey_to_validate_against );
                        if ( !conditional_is_valid ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid cond-sig data (invalid sig) so it will be ignored` );
                        }
                        var conditional_cosignature = tapscript.Signer.taproot.sign( privkey, new_tx1, 0, { extension: new_tx1_target }).hex;
                    }

                    //If necessary, validate the preimage by which the sender
                    //fully revokes the old state and sign the revocation
                    var full_revocation_is_necessary = false;
                    if ( am_alice && hedgehog.state[ chan_id ].bobs_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                    if ( !am_alice && hedgehog.state[ chan_id ].alices_revocation_hashes.length > 2 ) full_revocation_is_necessary = true;
                    if ( full_revocation_is_necessary ) {
                        if ( !( "full_revocation_preimage" in data ) ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid full-rev data (no pmg) so it will be ignored` );
                        }
                        //TODO: ensure checking this sig doesn't crash the app
                        if ( am_alice ) var prev_address = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 2 ][ 0 ];
                        else var prev_address = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 2 ][ 0 ];
                        if ( am_alice ) var prev_scripts = hedgehog.state[ chan_id ].bob_can_revoke[ hedgehog.state[ chan_id ].bob_can_revoke.length - 2 ][ 1 ];
                        else var prev_scripts = hedgehog.state[ chan_id ].alice_can_revoke[ hedgehog.state[ chan_id ].alice_can_revoke.length - 2 ][ 1 ];
                        var preimage = data[ "full_revocation_preimage" ];
                        var expected_hash = prev_scripts[ 1 ][ 1 ];
                        var hash_provided = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                        if ( hash_provided != expected_hash ) {
                            //restore old state and inform user this state update was invalid
                            if ( am_alice ) {
                                hedgehog.state[ chan_id ].bobs_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].alice_can_revoke.push( other_rev_info );
                            } else {
                                hedgehog.state[ chan_id ].alices_revocation_hashes.push( old_rev_hashes );
                                hedgehog.state[ chan_id ].bob_can_revoke.push( other_rev_info );
                            }
                            return alert( `Your counterparty sent you invalid full-rev data (wrg pmg) so it will be ignored` );
                        }
                        var prev_tx0 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( utxo_info[ "txid" ], utxo_info[ "vout" ], original_amnt, hedgehog.state[ chan_id ][ "multisig" ] )],
                            vout: [hedgehog.getVout( original_amnt - 500, prev_address )],
                        });
                        var doubly_prev_txid = tapscript.Tx.util.getTxid( prev_tx0 );
                        if ( am_alice ) var my_address = alices_address;
                        else var my_address = bobs_address;
                        var tx2 = tapscript.Tx.create({
                            vin: [hedgehog.getVin( doubly_prev_txid, 0, original_amnt - 500, prev_address )],
                            vout: [hedgehog.getVout( original_amnt - 500 - 500, my_address )],
                        });
                        var tx2_script = prev_scripts[ 1 ];
                        var tx2_target = tapscript.Tap.encodeScript( tx2_script );
                        var tx2_tree = prev_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                        var full_revocation_sig = tapscript.Signer.taproot.sign( privkey, tx2, 0, { extension: tx2_target }).hex;
                    }

                    //prepare and save the force closure initiation transaction
                    var [ _, cblock ] = tapscript.Tap.getPubKey( hedgehog.nums_point, { tree: tx0_tree, target: tx0_target });
                    //the order of the pubkeys is Alice first, then Bob, so -- if I am alice --
                    //the first sig must be sig_2 -- which means it must be in the "last"
                    //position (i.e. the sig created by Alice must appear right before her pubkey)
                    if ( am_alice ) tx0.vin[ 0 ].witness = [ sig_1, sig_2, tx0_script, cblock ];
                    else tx0.vin[ 0 ].witness = [ sig_2, sig_1, tx0_script, cblock ];

                    //prepare the force closure finalization transaction
                    var [ _, cblock ] = tapscript.Tap.getPubKey( hedgehog.nums_point, { tree: tx1_tree, target: tx1_target });
                    if ( am_alice ) tx1.vin[ 0 ].witness = [ sig_3, sig_4, tx1_script, cblock ];
                    else tx1.vin[ 0 ].witness = [ sig_4, sig_3, tx1_script, cblock ];

                    //if necessary, prepare and save the conditional revocation transaction
                    if ( conditional_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( hedgehog.nums_point, { tree: new_tx1_tree, target: new_tx1_target });
                        if ( am_alice ) new_tx1.vin[ 0 ].witness = [ conditional_revocation_sig, conditional_cosignature, new_tx1_script, cblock ];
                        else new_tx1.vin[ 0 ].witness = [ conditional_cosignature, conditional_revocation_sig, tx1_script, cblock ];
                    }

                    //if necessary, prepare and save the conditional revocation transaction
                    if ( full_revocation_is_necessary ) {
                        var [ _, cblock ] = tapscript.Tap.getPubKey( hedgehog.nums_point, { tree: tx2_tree, target: tx2_target });
                        tx2.vin[ 0 ].witness = [ full_revocation_sig, preimage, tx2_script, cblock ];
                    }

                    //save the transactions
                    hedgehog.state[ chan_id ].latest_force_close_txs = [
                        tapscript.Tx.encode( tx0 ).hex,
                        tapscript.Tx.encode( tx1 ).hex,
                    ];
                    if ( conditional_revocation_is_necessary ) {
                        hedgehog.state[ chan_id ].txids_to_watch_for[ prev_txid ] = {
                            tx0: tapscript.Tx.encode( tx0 ).hex,
                            conditional_revocation_tx: tapscript.Tx.encode( new_tx1 ).hex,
                        }
                    }
                    if ( full_revocation_is_necessary ) hedgehog.state[ chan_id ].txids_to_watch_for[ doubly_prev_txid ][ "full_revocation_tx" ] = tapscript.Tx.encode( tx2 ).hex;

                    //update the balances
                    if ( am_alice ) {
                        hedgehog.state[ chan_id ].balances = [ balances[ 0 ] + amnt, balances[ 1 ] - amnt ];
                    } else {
                        hedgehog.state[ chan_id ].balances = [ balances[ 0 ] - amnt, balances[ 1 ] + amnt ];
                    }

                    //update state of who was last to send
                    hedgehog.state[ chan_id ].i_was_last_to_send = false;

                    return true;
                },
                closeChannel: async chan_id => {
                    hedgehog.state[ chan_id ].i_force_closed = true;
                    console.log( "Broadcast this transaction to initiate a force closure:" );
                    console.log( hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ] );
                    await chain_client.commander( hedgehog_workshop.network_string.split( "," ), "broadcast", hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ] );
                    var auto = false;
                    hedgehog_workshop.stateLoop( auto );
                    //TODO: change the 5 to a 2016
                    console.log( "Wait 5 blocks and broadcast this transaction to finalize the force closure:" );
                    console.log( hedgehog.state[ chan_id ].latest_force_close_txs[ 1 ] );
                }
            }
        </script>
        <script>
            var hedgehog_workshop = {
                faucet_usable: true,
                testnet_privkey: null,
                network_string: null,
                btc_privkey: null,
                btc_address: null,
                utxos: {},
                relays: [ "ws://127.0.0.1:6969" ],
                // relays: [ "wss://no.str.cr" ],
                channels_being_closed: {},
                isValidHex: hex => {
                    if ( !hex ) return;
                    var length = hex.length;
                    if ( length % 2 ) return;
                    try {
                        var bigint = BigInt( "0x" + hex, "hex" );
                    } catch( e ) {
                        return;
                    }
                    var prepad = bigint.toString( 16 );
                    var i; for ( i=0; i<length; i++ ) prepad = "0" + prepad;
                    var padding = prepad.slice( -Math.abs( length ) );
                    return ( padding === hex );
                },
                useFaucet: async ( amnt = 5_000_000 ) => {
                    if ( !hedgehog_workshop.faucet_usable ) return;
                    hedgehog_workshop.faucet_usable = false;
                    var address = hedgehog_workshop.btc_address;
                    var privkey = hedgehog_workshop.btc_privkey;
                    var feerate = 1;
                    var txhex = await chain_client.commander( hedgehog_workshop.network_string.split( "," ), "send", {destino: address, amnt, feerate} );
                    var tx = tapscript.Tx.decode( txhex );
                    var txid = tapscript.Tx.util.getTxid( txhex );
                    var vout_i_seek = -1;
                    var value_i_received = 0;
                    tx.vout.forEach( ( output, index ) => {
                        var address_that_got_money = tapscript.Address.fromScriptPubKey( output.scriptPubKey, hedgehog.network );
                        if ( address_that_got_money !== address ) return;
                        vout_i_seek = index;
                        value_i_received = Number( output.value );
                    });
                },
                getBalances: async () => {
                    var address = hedgehog_workshop.btc_address;
                    if ( !address ) return { confirmed_balance: 0, unconfirmed_balance: 0 }
                    hedgehog_workshop.utxos = await chain_client.commander( hedgehog_workshop.network_string.split( "," ), "utxos", address );
                    var confirmed_balance = 0;
                    var unconfirmed_balance = 0;
                    var i; for ( i=0; i<hedgehog_workshop.utxos.length; i++ ) {
                        var utxo = hedgehog_workshop.utxos[ i ];
                        var txid = utxo.txid;
                        var vout = utxo.vout;
                        var rawtx = await chain_client.commander( hedgehog_workshop.network_string.split( "," ), "rawtx", txid );
                        var tx = tapscript.Tx.decode( rawtx );
                        var output = tx.vout[ vout ];
                        var address_that_got_money = tapscript.Address.fromScriptPubKey( output.scriptPubKey, hedgehog.network );
                        if ( address_that_got_money !== address ) continue;
                        if ( utxo.status.confirmed ) confirmed_balance = confirmed_balance + utxo.value;
                        else unconfirmed_balance = unconfirmed_balance + utxo.value;
                    }
                    return { confirmed_balance, unconfirmed_balance }
                },
                spendCoins: async ( destino, amt, sats_per_byte, utxos, change_address ) => {
                    var inputs = [];
                    var outputs = [];
                    var from_amount = 0;
                    utxos.forEach( utxo => {
                        from_amount = from_amount + utxo[ "value" ];
                        var txid = utxo[ "txid" ];
                        var vout = utxo[ "vout" ];
                        var amount = utxo[ "value" ];
                        inputs.push({
                            txid: txid,
                            vout: vout,
                            prevout: {
                                value: amount,
                                scriptPubKey: tapscript.Address.toScriptPubKey( utxo[ "address" ] ),
                            },
                        });
                    });
                    if ( !from_amount ) return alert( "You cannot spend without money. Please make a deposit, then try again." );
                    var to_amount = amt;
                    var there_be_dust = false;
                    outputs.push({
                        value: to_amount,
                        scriptPubKey: tapscript.Address.toScriptPubKey( destino ),
                    });
                    if ( to_amount < 330 ) there_be_dust = true;
                    if ( there_be_dust ) return alert( "You cannot send less than 330 sats because that is bitcoin's dust limit. Please try again" );
                    if ( from_amount - to_amount < 1 ) return alert( "You must leave enough to pay a mining fee, please try again" );
                    var txsize = 0;
                    inputs.forEach( item => txsize = txsize + 64 + 32 + 8 );
                    var i; for ( i=0; i<outputs.length; i++ ) {
                        //I calculate that outputs add 30 bytes apiece by
                        //assuming the average scriptpubkey is 26 bytes
                        //and assuming amounts are denoted in 4 bytes
                        txsize = txsize + 30;
                    }
                    var mining_fee = txsize * sats_per_byte;
                    if ( mining_fee < 172 ) mining_fee = 172;
                    if ( from_amount - to_amount < mining_fee ) return alert( `With your chosen fee rate you must leave at least ${mining_fee} sats to pay for mining fees, which means the max you can spend is ${from_amount - mining_fee} sats. Please try again` );
                    if ( from_amount - ( to_amount + mining_fee ) >= 330 ) {
                        outputs.push({
                            value: from_amount - ( to_amount + mining_fee ),
                            scriptPubKey: tapscript.Address.toScriptPubKey( change_address ),
                        });
                    }
                    var txdata = tapscript.Tx.create({
                        vin: inputs,
                        vout: outputs,
                    });
                    utxos.forEach( ( utxo, index ) => {
                        var privkey = utxo[ "privkey" ];
                        var sig = tapscript.Signer.taproot.sign( privkey, txdata, index );
                        txdata.vin[ index ].witness = [ sig ];
                    });
                    var txhex = tapscript.Tx.encode( txdata ).hex;
                    return txhex;
                },
                stateLoop: async ( auto = true ) => {
                    //Show status of active channels
                    var div = document.createElement( "div" );
                    var total_hh_balance = 0;
                    var channels_to_remove = [];
                    var i; for ( i=0; i<Object.keys( hedgehog.state ).length; i++ ) {
                        var chan_id = Object.keys( hedgehog.state )[ i ];
                        var channel_label = hedgehog.state[ chan_id ].label;

                        //ensure channel still exists
                        var channel_utxos = await chain_client.commander( hedgehog_workshop.network_string.split( "," ), "utxos", hedgehog.state[ chan_id ].multisig );
                        var channel_ceased = true;
                        channel_utxos.forEach( utxo => {
                            if ( utxo.txid !== hedgehog.state[ chan_id ].multisig_utxo_info.txid ) return;
                            channel_ceased = false;
                        });
                        if ( channel_ceased ) {
                            channels_to_remove.push( chan_id );
                            continue;
                        }

                        var inner = document.createElement( "div" );
                        var html = `
                            <div>
                                <p>Label: <span class="channel_label">loading...</span></p>
                                <p>Balance: <span class="channel_balance">0</span> sats</p>
                                <p><button class="close_channel">Close channel</button> <button class="channel_send_btn">Send</button> <button class="channel_receive_btn">Receive</button></p>
                            </div>
                        `;
                        inner.innerHTML = html;
                        inner = inner.firstElementChild;
                        inner.classList.add( `channel` );
                        inner.classList.add( `channel_${chan_id}` );
                        inner.classList.add( `bordered` );
                        inner.setAttribute( "data-chan_id", chan_id );
                        inner.getElementsByClassName( "channel_label" )[ 0 ].innerText = channel_label;
                        var channel_balance = hedgehog.state[ chan_id ].alices_privkey ? hedgehog.state[ chan_id ].balances[ 0 ] || 0 : hedgehog.state[ chan_id ].balances[ 1 ] || 0;
                        total_hh_balance = total_hh_balance + channel_balance;
                        inner.getElementsByClassName( "channel_balance" )[ 0 ].innerText = channel_balance.toLocaleString();
                        inner.getElementsByClassName( "close_channel" )[ 0 ].onclick = () => hedgehog.closeChannel( chan_id );
                        inner.getElementsByClassName( "channel_send_btn" )[ 0 ].onclick = () => {
                            $( '.instructions' ).innerHTML = `
                                <p>Send this data to your recipient and have them click the "Receive on hedgehog" button:</p>
                                <p>${JSON.stringify( hedgehog.send( chan_id ) )}</p>
                            `;
                            var auto = false;
                            hedgehog_workshop.stateLoop( auto );
                        }
                        inner.getElementsByClassName( "channel_receive_btn" )[ 0 ].onclick = async () => {
                            var all_good = await hedgehog.receive();
                            var auto = false;
                            hedgehog_workshop.stateLoop( auto );
                        }
                        div.append( inner );
                    }

                    //show status of closing channels
                    var i; for ( i=0; i<Object.keys( hedgehog_workshop.channels_being_closed ).length; i++ ) {
                        var chan_id = Object.keys( hedgehog_workshop.channels_being_closed )[ i ];
                        var channel_data = hedgehog_workshop.channels_being_closed[ chan_id ];

                        //prepare variables
                        var channel_label = channel_data.label;
                        var money_coming_to_you = channel_data.money_coming_to_you;
                        if ( channel_data.hasOwnProperty( "force_close_txs" ) ) {
                            var tx_to_broadcast = channel_data.force_close_txs[ 1 ];
                            var type_of_tx = "finalization_tx";
                            var blockheight = await chain_client.commander( hedgehog_workshop.network_string.split( "," ), "blockheight" );
                            var txid_of_tx0 = channel_data.txid_of_tx0;
                            var revocable_address = channel_data.revocable_address;
                            var conf_data = await chain_client.commander( hedgehog_workshop.network_string.split( "," ), "utxos", revocable_address );
                            var info_i_seek = null;
                            conf_data.every( utxo => {
                                if ( utxo.txid !== txid_of_tx0 ) return true;
                                info_i_seek = utxo;
                            });
                            if ( !info_i_seek || !info_i_seek.hasOwnProperty( "status"  ) || !info_i_seek.status.hasOwnProperty( "confirmed" ) ) {
                                chain_client.commander( hedgehog_workshop.network_string.split( "," ), "broadcast", tx_to_broadcast );
                                var waiting_for = `Nothing! The transaction corresponding to your latest state was broadcasted and all is well. You should see ${money_coming_to_you.toLocaleString()} sats arrive in your wallet any second.`;
                            } else {
                                var num_of_confs = 0;
                                if ( info_i_seek.status.confirmed ) num_of_confs = blockheight - info_i_seek.status.block_height;
                                var waiting_for = `You are waiting for confirmations. Hedgehog force closures require two transactions to force close a channel; you've already broadcasted the first one, but the second one is timelocked and cannot be broadcasted til the first one has 5 confirmations. It currently has ${num_of_confs}, so you are waiting for ${5 - num_of_confs} confirmations. When the time is right, your app will broadcast this tx: <br><br>${tx_to_broadcast}`;
                                if ( num_of_confs >= 5 ) chain_client.commander( hedgehog_workshop.network_string.split( "," ), "broadcast", tx_to_broadcast );
                            }
                        } else {
                            var tx_to_broadcast = null;
                            var type_of_tx = null;
                            var waiting_for = null;
                            if ( channel_data.force_close_data.hasOwnProperty( "full_revocation_tx" ) ) {
                                tx_to_broadcast = channel_data.force_close_data.full_revocation_tx;
                                type_of_tx = "full_revocation_tx";
                                chain_client.commander( hedgehog_workshop.network_string.split( "," ), "broadcast", tx_to_broadcast );
                                money_coming_to_you = Number( tapscript.Tx.decode( tx_to_broadcast ).vout[ 0 ].value );
                                waiting_for = `Nothing! Your counterparty broadcasted very old state so we broadcasted the penalty tx and you should see ${money_coming_to_you.toLocaleString()} sats arrive in your wallet any second.`;
                            } else if ( channel_data.force_close_data.hasOwnProperty( "conditional_revocation_tx" ) ) {
                                tx_to_broadcast = channel_data.force_close_data.conditional_revocation_tx;
                                type_of_tx = "conditional_revocation_tx";
                                chain_client.commander( hedgehog_workshop.network_string.split( "," ), "broadcast", tx_to_broadcast );
                                waiting_for = `Nothing! Your counterparty broadcasted the transaction corresponding to his or her most recent state, which does not quite match yours, so you updated the transaction to your latest one. You should see ${money_coming_to_you.toLocaleString()} sats arrive in your wallet any second.`;
                            } else {
                                tx_to_broadcast = channel_data.force_close_data.timeout_tx;
                                type_of_tx = "timeout_tx";
                                var blockheight = await chain_client.commander( hedgehog_workshop.network_string.split( "," ), "blockheight" );
                                var txid_of_tx0 = channel_data.txid_of_tx0;
                                var revocable_address = channel_data.revocable_address;
                                var conf_data = await chain_client.commander( hedgehog_workshop.network_string.split( "," ), "utxos", revocable_address );
                                var info_i_seek = null;
                                conf_data.every( utxo => {
                                    if ( utxo.txid !== txid_of_tx0 ) return true;
                                    info_i_seek = utxo;
                                });
                                if ( !info_i_seek || !info_i_seek.hasOwnProperty( "status"  ) || !info_i_seek.status.hasOwnProperty( "confirmed" ) ) {
                                    chain_client.commander( hedgehog_workshop.network_string.split( "," ), "broadcast", tx_to_broadcast );
                                    var waiting_for = `Nothing! The transaction corresponding to your latest state was broadcasted and all is well. You should see ${money_coming_to_you.toLocaleString()} sats arrive in your wallet any second.`;
                                } else {
                                    var num_of_confs = 0;
                                    if ( info_i_seek.status.confirmed ) num_of_confs = blockheight - info_i_seek.status.block_height;
                                    waiting_for = `You are waiting for confirmations. Hedgehog force closures require two transactions to force close a channel; your counterparty already broadcasted the first one, but the second one is timelocked and cannot be broadcasted til the first one has 5 confirmations. It currently has ${num_of_confs}, so you are waiting for ${5 - num_of_confs} confirmations. When the time is right, you should see ${money_coming_to_you.toLocaleString()} sats arrive in your wallet. If your counterparty disappears and thus never finalizes the force closure, then after 10 confirmations, you get to broadcast a penalty tx that earns you ${( Number( tapscript.Tx.decode( tx_to_broadcast ).vout[ 0 ].value )  + 1_000 ).toLocaleString()} sats. Your app is waiting ${10 - num_of_confs} more confirmations from now to do that, but it probably won't happen if your counterparty is honest. This is the penalty tx:<br><br>${tx_to_broadcast}`;
                                    if ( num_of_confs >= 10 ) chain_client.commander( hedgehog_workshop.network_string.split( "," ), "broadcast", tx_to_broadcast );
                                }
                            }
                        }

                        var inner = document.createElement( "div" );
                        var html = `
                            <div>
                                <p>Label: <span class="channel_label">loading...</span></p>
                                <p>Money coming to you: <span class="money_coming_to_you">0</span> sats</p>
                                <p>What you are waiting for: <span class="waiting_for"></span></p>
                            </div>
                        `;
                        inner.innerHTML = html;
                        inner = inner.firstElementChild;
                        inner.classList.add( `channel` );
                        inner.classList.add( `channel_${chan_id}` );
                        inner.classList.add( `bordered` );
                        inner.setAttribute( "data-chan_id", chan_id );
                        inner.getElementsByClassName( "channel_label" )[ 0 ].innerText = channel_label;
                        inner.getElementsByClassName( "money_coming_to_you" )[ 0 ].innerText = money_coming_to_you.toLocaleString();
                        inner.getElementsByClassName( "waiting_for" )[ 0 ].innerHTML = waiting_for;
                        div.append( inner );
                    }

                    if ( !div.children.length ) {
                        var para = document.createElement( "p" );
                        para.innerText = `[None yet]`;
                        div.append( para );
                    }

                    //display the info
                    $( '.channels_list' ).innerHTML = ``;
                    while ( div.children.length ) {
                        var chan_id = div.children[ 0 ].hasAttribute( "data-chan_id" ) ? div.children[ 0 ].getAttribute( "data-chan_id" ) : "";
                        if ( $( `.channel_${chan_id}` ) ) div.splice( 0, 1 );
                        else $( '.channels_list' ).append( div.children[ 0 ] );
                    }

                    //Remove any closed channels
                    var i; for ( i=0; i<channels_to_remove.length; i++ ) {
                        var chan_id = channels_to_remove[ i ];
                        if ( hedgehog.state[ chan_id ].i_force_closed ) {
                            //you are the person who broadcasted the tx
                            var i_am_alice = !!hedgehog.state[ chan_id ].alices_privkey;
                            var money_coming_to_you = i_am_alice ? hedgehog.state[ chan_id ].balances[ 0 ] : hedgehog.state[ chan_id ].balances[ 1 ];
                            var force_close_txs = hedgehog.state[ chan_id ].latest_force_close_txs;
                            var label = hedgehog.state[ chan_id ].label;
                            var txid_of_tx0 = tapscript.Tx.util.getTxid( hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ] );
                            var spky = tapscript.Tx.decode( hedgehog.state[ chan_id ].latest_force_close_txs[ 0 ] ).vout[ 0 ].scriptPubKey;
                            var revocable_address = tapscript.Address.fromScriptPubKey( spky, hedgehog.network );
                            hedgehog_workshop.channels_being_closed[ chan_id ] = { label, force_close_txs, i_am_alice, money_coming_to_you, txid_of_tx0, revocable_address };
                            delete hedgehog.state[ chan_id ];
                        } else {
                            //find out if your counterparty broadcasted the right tx
                            var closure_txids = Object.keys( hedgehog.state[ chan_id ].txids_to_watch_for );
                            var force_close_data = null;
                            var j; for ( j=0; j<closure_txids.length; j++ ) {
                                var tx_exists = await chain_client.commander( hedgehog_workshop.network_string.split( "," ), "rawtx", closure_txids[ i ] );
                                if ( !hedgehog.isValidHex( tx_exists ) ) continue;
                                force_close_data = { ...hedgehog.state[ chan_id ].txids_to_watch_for[ closure_txids[ i ] ], txid: closure_txids[ i ]} ;
                                break;
                            }
                            if ( force_close_data ) {
                                var i_am_alice = !!hedgehog.state[ chan_id ].alices_privkey;
                                var money_coming_to_you = i_am_alice ? hedgehog.state[ chan_id ].balances[ 0 ] : hedgehog.state[ chan_id ].balances[ 1 ];
                                var label = hedgehog.state[ chan_id ].label;
                                var multisig = hedgehog.state[ chan_id ].multisig;
                                var txid_of_tx0 = force_close_data.txid;
                                var spky = tapscript.Tx.decode( force_close_data.tx0 ).vout[ 0 ].scriptPubKey;
                                var revocable_address = tapscript.Address.fromScriptPubKey( spky, hedgehog.network );
                                hedgehog_workshop.channels_being_closed[ chan_id ] = { label, force_close_data, i_am_alice, money_coming_to_you, txid_of_tx0, revocable_address };
                                delete hedgehog.state[ chan_id ];
                            }
                        }
                    }

                    //Update hedgehog balance
                    $( '.hedgehog_balance' ).innerText = total_hh_balance.toLocaleString();

                    //Update L1 balances
                    var { confirmed_balance, unconfirmed_balance } = await hedgehog_workshop.getBalances();
                    $( '.confirmed_balance' ).innerText = confirmed_balance.toLocaleString();
                    $( '.unconfirmed_balance' ).innerText = unconfirmed_balance.toLocaleString();
                    await chain_client.waitSomeTime( 5_000 );
                    if ( auto ) hedgehog_workshop.stateLoop();
                },
                shareChannelOpeningData: () => {
                    var privkey = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                    var pubkey = nobleSecp256k1.getPublicKey( privkey, true ).substring( 2 );
                    var preimage = hedgehog.bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).substring( 0, 32 );
                    var hash = hedgehog.rmd160( hedgehog.hexToBytes( preimage ) );
                    hedgehog.keypairs[ pubkey ] = {privkey, preimage};
                    var address = hedgehog_workshop.btc_address;
                    $( '.instructions' ).innerHTML = `
                        <p>Share the following channel opening data with someone who wants to open a channel to you:</p>
                        <p>${JSON.stringify( [ pubkey, hash, address ] )}</p>
                    `;
                }
            }
        </script>
        <style>
            * {
                box-sizing: border-box;
                font-size: 1.15rem;
                font-family: Arial, sans-serif;
            }
            html {
                max-width: 800px;
                padding: 3rem 1rem;
                margin: auto;
                line-height: 1.25;
                padding: 0;
            }
            body {
                margin: 3rem 1rem;
                word-wrap: break-word;
            }
            h1 {
                font-size: 2rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            input {
                line-height: 1.25;
                width: 100%;
                height: 1.8rem;
                font-size: 1.15rem;
                border: 1px solid grey;
            }
            .hidden {
                display: none !important;
            }
            .wallet_page {
                max-width: 25rem;
                margin: auto;
            }
            .bordered {
                border: 1px solid black;
                border-radius: 1rem;
                padding: 1rem;
            }
            .channel {
                margin-top: 1rem;
            }
            .instructions_div {
                padding: 1rem;
                background-color: #cccccc;
            }
            .instructions_div * {
                font-family: monospace;
            }
            @media screen and (max-width: 600px) {
            }
        </style>
        <style>
            .black-bg {
                width: 100%;
                position: fixed;
                top: 0;
                left: 0;
                background-color: black;
                opacity: .5;
                width: 100vw;
                height: 100vh;
            }
            .modal {
                position: fixed;
                box-sizing: border-box;
                top: 50%;
                left: 50%;
                transform: translate(-50%,-50%);
                width: 90%;
                max-width: 560px;
                background-color: white;
                border-radius: 1rem;
                padding: 20px;
                color: black;
                text-align: center;
                word-wrap: break-word;
            }
            .modal * {
                color: black;
            }
            .modal input, .modal textarea {
                max-width: 90%;
            }
        </style>
        <script>
            var modalVanish = () => {
                $( ".black-bg" ).classList.add( "hidden" );
                $( ".modal" ).classList.add( "hidden" );
            }
            var showModal = content => {
                $( ".modal" ).innerHTML = `<div class="x_modal" style="position: absolute;right: 1rem;top: 0.5rem;font-size: 2rem; cursor: pointer; color: black;" onclick="modalVanish()">&times;</div>`;
                $( ".modal" ).innerHTML += `<div style="overflow-y: auto; max-height: 80vh; margin-top: 1.5rem;">${content}</div>`;
                $( ".black-bg" ).classList.remove( "hidden" );
                $( ".modal" ).classList.remove( "hidden" );
            }
        </script>
        <script>
            var $ = document.querySelector.bind( document );
            var $$ = document.querySelectorAll.bind( document );
            var url_params = new URLSearchParams( window.location.search );
            var url_keys = url_params.keys();
            var $_GET = {}
            for ( var key of url_keys ) $_GET[ key ] = url_params.get( key );
            var hash_arr = window.location.href.substring( window.location.href.indexOf( "#" ) ).split( "#" );
            hash_arr.splice( 0, 1 );
            var $_HASH = {}
            hash_arr.forEach( item => {
                var vals = item.split( "=" );
                $_HASH[ vals[ 0 ] ] = vals[ 1 ];
            });
        </script>
    </head>
    <body>
        <div class="hideable_page home_page">
            <h1>Hedgehog Workshop</h1>
            <p style="font-weight:bold;">Network string (share this with others):</p>
            <p class="network_string">loading...</p>
            <p><button class="genblock hidden">Generate block</button></p>
        </div>
        <div class="hideable_page loading_page hidden">
            <p>loading...</p>
        </div>
        <div class="hideable_page wallet_page hidden">
            <h1>Wallet</h1>
            <hr>
            <p style="font-weight: bold; text-align: center;">Your address</p>
            <p style="text-align: center;" class="btc_address"></p>
            <hr>
            <p>Confirmed L1 balance: <span class="confirmed_balance">0</span> sats</p>
            <p>Unconfirmed L1 balance: <span class="unconfirmed_balance">0</span> sats</p>
            <p>Confirmed L2 balance: <span class="hedgehog_balance">0</span> sats</p>
            <hr>
            <p><button class="use_faucet">Use faucet</button> <button class="send_on_L1">Send on L1</button></p>
            <p><button class="send_btn">Send on hedgehog</button> <button class="receive_btn">Receive on hedgehog</button></p>
            <p><button class="manage_channels">Manage channels</button></p>
            <p><button class="share_channel_opening_data">Share channel opening data</button></p>
            <div class="instructions_div">
                <p>Instructions:</p>
                <div class="instructions">
                    <p>To start, the Channel Opener should click the Use Faucet button</p>
                    <p>Then that person should click Manage Channels -> Open Channel and follow the instructions</p>
                    <p>Then the Channel Recipient click Receive on Hedgehog</p>
                </div>
            </div>
        </div>
        <div class="hideable_page manage_channels_page hidden">
            <h2>Manage channels</h2>
            <p><button class="back_btn">Back</button> <button class="open_channel">Open channel</button></p>
            <p style="font-weight: bold;">List of channels</p>
            <div class="channels_list"></div>
        </div>
        <script>
            var showPage = page => {
                $$( '.hideable_page' ).forEach( page => page.classList.add( "hidden" ) );
                $( `.${page}` ).classList.remove( "hidden" );
            }
            $( `.use_faucet` ).onclick = async () => {
                if ( !hedgehog_workshop.faucet_usable ) return alert( 'faucet may only be used once' );
                await hedgehog_workshop.useFaucet();
                var { confirmed_balance, unconfirmed_balance } = await hedgehog_workshop.getBalances();
                $( '.confirmed_balance' ).innerText = confirmed_balance.toLocaleString();
                $( '.unconfirmed_balance' ).innerText = unconfirmed_balance.toLocaleString();
            }
            $( '.send_on_L1' ).onclick = async () => {
                var address = prompt( `enter a btc address you want to send to` );
                if ( !address ) return;
                var amnt = Number( prompt( `enter an amount of sats you want to send there` ) );
                if ( !amnt ) return;
                if ( amnt < 330 ) return alert( 'try again, the minimum amount is 330 sats' );
                var sats_per_byte = 1;
                var utxos = JSON.parse( JSON.stringify( hedgehog_workshop.utxos ) );
                utxos.forEach( ( utxo, index ) => {
                    utxos[ index ][ "address" ] = hedgehog_workshop.btc_address;
                    utxos[ index ][ "privkey" ] = hedgehog_workshop.btc_privkey;
                });
                var change_address = hedgehog_workshop.btc_address;
                var txhex = await hedgehog_workshop.spendCoins( address, amnt, sats_per_byte, utxos, change_address );
                chain_client.commander( hedgehog_workshop.network_string.split( "," ), "broadcast", txhex );
            }
            $( '.send_btn' ).onclick = () => {
                if ( !Object.keys( hedgehog.state ).length ) return alert( `open a channel first using the Manage Channels button` );
                    // <select name="cars" id="cars" form="carform">
                var html = `
                    <p>Select a channel</p>
                    <select class="send_form">
                `;
                var i; for ( i=0; i<Object.keys( hedgehog.state ).length; i++ ) {
                    var chan_id = Object.keys( hedgehog.state )[ i ];
                    var channel_label = hedgehog.state[ chan_id ].label;
                    var channel_balance = hedgehog.state[ chan_id ].alices_privkey ? hedgehog.state[ chan_id ].balances[ 0 ] || 0 : hedgehog.state[ chan_id ].balances[ 1 ] || 0;
                    var html = html + `
                        <option value="${chan_id}">${channel_label} | ${channel_balance} sats</option>
                    `;
                }
                html = html + `</select>
                    <p>Enter an amount of sats to send</p>
                    <p><input class="amnt_to_send" type="number" min="1" value="1" step="1" max="${channel_balance}"></p>
                    <p><button class="submit_send">Submit</button></p>
                `;
                showModal( html );
                $( '.amnt_to_send' ).focus();
                $( '.amnt_to_send' ).select();
                $( '.amnt_to_send' ).addEventListener( "keydown", e => {
                    if ( e.key === "Enter" ) $( '.submit_send' ).click();
                });
                $( '.submit_send' ).onclick = async () => {
                    var chan_id = $( '.send_form' ).value;
                    var amnt = Number( $( '.amnt_to_send' ).value );
                    $( '.instructions' ).innerHTML = `
                        <p>Send this data to your recipient and have them click the "Receive on hedgehog" button:</p>
                        <p>${JSON.stringify( hedgehog.send( chan_id, amnt ) )}</p>
                    `;
                    $( '.x_modal' ).click();
                    var auto = false;
                    hedgehog_workshop.stateLoop( auto );
                }
            }
            $( '.receive_btn' ).onclick = async () => {
                var all_good = await hedgehog.receive();
                var auto = false;
                hedgehog_workshop.stateLoop( auto );
                $( '.instructions' ).innerHTML = `
                    <p>Now that you've received money, you can also send it by clicking the Send on Hedgehog button</p>
                `;
            }
            $( '.manage_channels' ).onclick = () => showPage( 'manage_channels_page' );
            $( '.share_channel_opening_data' ).onclick = () => {hedgehog_workshop.shareChannelOpeningData();}
            $( '.open_channel' ).onclick = async () => {
                var push_all_funds_to_counterparty = true;
                var sigs_and_stuff = await hedgehog.openChannel( push_all_funds_to_counterparty );
                if ( !sigs_and_stuff ) return;
                var auto = false;
                hedgehog_workshop.stateLoop( auto );
                $( '.instructions' ).innerHTML = `
                    <p>Send this data to your recipient and have them click the "Receive on hedgehog" button:</p>
                    <p>${JSON.stringify( sigs_and_stuff )}</p>
                `;
                showPage( 'wallet_page' );
            }
            $$( '.back_btn' ).forEach( btn => btn.onclick = () => showPage( 'wallet_page' ) );
            if ( $_HASH.admin ) {
                var start = async () => {
                    var relay = prompt( `please enter a nostr relay e.g. ${hedgehog_workshop.relays[ 0 ]}`, hedgehog_workshop.relays[ 0 ] );
                    var [ testnet_privkey, network_string ] = await chain_client.createNetwork( [ relay ] );
                    hedgehog_workshop.testnet_privkey = testnet_privkey;
                    hedgehog_workshop.network_string = network_string;
                    chain_client.commander( hedgehog_workshop.network_string.split( "," ), "genblock" );
                    $( '.network_string' ).innerText = hedgehog_workshop.network_string;
                    $( '.genblock' ).classList.remove( "hidden" );
                    $( '.genblock' ).onclick = () => chain_client.commander( hedgehog_workshop.network_string.split( "," ), "genblock" );
                }
                start();
            } else {
                showPage( 'loading_page' );
                var start = async () => {
                    var network = $_HASH.network ? $_HASH.network : prompt( `enter a network string\n\nto generate one, open a new tab and copy the url, but add #admin=true to it` );
                    var [ _, network_string ] = await chain_client.loadNetwork( null, network );
                    hedgehog_workshop.network_string = network_string;
                    console.log( `I am connected, right?`, !!hedgehog_workshop.network_string );
                    var testnet_pubkey = network_string.split( "," )[ 0 ];
                    var hex_relays = chain_client.textToHex( JSON.stringify( [ network_string.split( "," )[ 1 ] ] ) );
                    console.log( `visit this url to view the blockchain:` );
                    console.log( chain_client.base_url + `#pubkey=${network_string.split( "," )[ 0 ]}#relays=${hex_relays}` );
                    var privkey = chain_client.getPrivkey();
                    var pubkey = chain_client.getPubkey( privkey );
                    var address = tapscript.Address.fromScriptPubKey( [ 1, pubkey ], hedgehog.network );
                    hedgehog_workshop.btc_privkey = privkey;
                    hedgehog_workshop.btc_address = address;
                    $( '.btc_address' ).innerText = address;
                    showPage( 'wallet_page' );
                    hedgehog_workshop.stateLoop();
                }
                start();
            }
        </script>
        <div class="black-bg hidden" onclick="modalVanish();"></div>
        <div class="modal hidden"></div>
    </body>
</html>
